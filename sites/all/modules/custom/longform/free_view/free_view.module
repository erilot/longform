<?php

/**
 * File: free_view.module
 *
 * Adds the ability to dynamically construct and view documents using
 * the taxonomy module as a framework.
 */

 /**
 * Implements hook_ctools_plugin_directory().
 */
function free_view_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'ctools' && $plugin_type == 'content_types') {
    return 'plugins/' . $plugin_type;
  }
}


/**
 * Continuous scroll development
 *
 */

 /**
  * Implements hook_menu().
  *
  */
 function free_view_menu(){
    $items['jsondata/dynamic/docs'] = array(
    'page callback' => 'free_view_output_topic_json',
    'access arguments' => array('access content'),
  );
  return $items;
 }
 
	/**
 * Implements hook_ctools_plugin_directory().
 */
function technet_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'ctools' && $plugin_type == 'content_types') {
    return 'plugins/' . $plugin_type;
  }
}

/**
 * Developer block
 *
 * Use this as a place to stash work during development, and assign it a location via panels.
 *
 */
function technet_developer_block() {
		$node = menu_get_object();
  if ($node->type != 'import_ticket') {
    return;
  }
		$wrap = entity_metadata_wrapper('node',$node);
		$break = substr($wrap->field_heading_split_level->value()->name, -1, 1);
		//$break = $wrap->field_heading_split_level->value()->tid;

		module_load_include('inc', 'doc_import', 'doc_import.build');
		$topics = _doc_manage_get_topics($node);
		foreach ($topics as $topic) {
				$nids[] = $topic->nid;
		}
  
  // NOTE: This seems like a super inefficient way to do this -- I load the nodes once, then pass them over
  // to get_topic_chunk() which pulls their content again? Look at this. Maybe rewrite get_topic_chunk() to use nids.
  
		$topics = node_load_multiple($nids);
		foreach($topics as $topic){
				$content[$topic->nid] = _doc_import_get_topic_chunk($topic, TRUE);
		}
		
		// dev
  
  //$new = technet_create_document_taxonomy_tree($node, $content, $node->title, TRUE);
  dpm($new,'new');
		$nested = technet_show_document_taxonomy_tree(9387);	
		
}

/**
 * Button to force-regenerate the dynamic book.
 *
 */
function free_view_generate_dynamic_document_form($form, &$form_state) {
  
  $form = array();
  $form['settings'] = array(
    '#type' => 'container',
    '#attributes' => array(
      'class' => array('row', 'panel', 'panel-info'),
    ),
  );

  $form['settings']['title'] = array(
    '#markup' => '<div class="panel-heading"><h3 class="panel-title">Generate dynamic document</h3></div>',
  );
  $form['settings']['wrap'] = array(
    '#type' => 'container',
    '#attributes' => array(
      'class' => array('panel-body'),
    ),    
  );
  $form['settings']['wrap']['left'] = array(
    '#type' => 'container',
    '#attributes' => array(
      'class' => array('col-md-6'),
    ),    
  );
  $options = array(0 => t('Add new'), 1 => t('Delete and replace'));
  $form['settings']['wrap']['left']['replace'] = array(
    '#type' => 'radios',
    '#title' => t('Add this content as a new document, or clean out the tree and replace it?'),
    '#options' => $options,
    '#default_value' => 1,
  );
  $form['settings']['wrap']['right'] = array(
    '#type' => 'container',
    '#attributes' => array(
      'class' => array('col-md-6'),
    ),    
  );
  $form['settings']['wrap']['right']['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Go now!',
    //'#attributes' => array(
    //  'class' => array('pull-right'),
    //),
    '#submit' => array('free_view_generate_dynamic_document_form_submit')
  );
  return $form;
}

/**
 * Submit handler for generate_dynamic_document_form
 */
function free_view_generate_dynamic_document_form_submit($form, &$form_state) {
  dpm($form_state,'form state');
}

/**
 * Return a structured (hierarchical) TOC based on a provided content array.
 *
 * The content array must be created by doc_import_construct_document_array().
 *
 * @var $ticket (object)
 * 	The import ticket object. If it's not supplied, the function will try to load it
 * 	using the current page.
 * 	
 * @var $content (array)
 * 	The content array generated by doc_import_construct_document_array().
 * 	If not supplied, the function will try to load it using the current page.
 *
 * @var $title (string)
 * 	The title to give the tree.
 *
 * @var $replace (boolean)
 *  Whether to wipe out the existing tree and replace it (TRUE), or add a new branch (FALSE).
 *  This is a debugging mode. Defaults to FALSE.
 *
 * @return
 * 	An array of new taxonomy term objects.
 * 	
 */
function technet_create_document_taxonomy_tree($ticket = NULL, $content = NULL, $title, $replace = FALSE) {
		if (!isset($ticket)) {
				$ticket = menu_get_object();
		}
		$vocab = taxonomy_vocabulary_machine_name_load('dynamic_documents_canon');
		$tree = taxonomy_get_tree($vocab->vid);
		
		// If the $replace flag is set, we are in debugging mode: delete the entire tree before proceeding.
		if ($replace == TRUE) {
				foreach ($tree as $leaf) {
						taxonomy_term_delete($leaf->tid);
				}
		}

		// Get a list of fields in both ticket and term: these are shared and will be copied.
  $target_fields = array_keys(
    array_filter(
      field_info_field_map(),
      function($array){
        return (in_array('import_ticket', $array['bundles']['node']) && in_array('dynamic_documents_canon', $array['bundles']['taxonomy_term']));
      }
    )
  );
  		
		$level = 1;
		$weight = 0;
		$level_store = array();

		// Set up title page term
		$title = new stdClass();
		$title->vid = $vocab->vid;
		$title->name = $ticket->title;
		$title->name_field['en'][0]['value'] = $ticket->title;
		$title->weight = -1; 
		$title->parent = array(0);
		$result = taxonomy_term_save($title);
		
		$terms[] = $title;
		$level_store[0] = $title->tid;
  
  // Add common fields
  foreach($target_fields as $field){
    $title->$field = $ticket->$field;
  }

		// Add child terms using the original document hierarchy
		foreach ($content as $item) {
				$level = $item['level'];
				$weight = $weight + 1;
				$term = new stdClass();
				$term->vid = $vocab->vid;
				$term->name = $item['title'];
				$term->name_field['en'][0]['value'] = $item['title'];
				$term->depth = $item['level'];
				$term->weight = $weight;
				$term->parent = $level_store[($level-1)];
				
    // Add term-specific fields
    $term->field_topic_reference[LANGUAGE_NONE][0]['target_id'] = $item['topic_nid'];
    
    // Add common fields
    foreach($target_fields as $field){
      $term->$field = $ticket->$field;
    }
    
				$result = taxonomy_term_save($term);
				$terms[] = $term;
				
				$level_store[$level] = $term->tid;
				$last_level = $level;
		}
		return $terms;
}

function technet_show_document_taxonomy_tree($tid) {
		$vocab = taxonomy_vocabulary_machine_name_load('dynamic_documents_canon');
		$tree = taxonomy_get_tree($vocab->vid, $tid);
		dpm($tree,'tree');

}

/**
 * Gets a rendered topic and returns it as json-encoded data.
 *
 * This is a menu callback intended for AJAX requests.
 *
 * @var $tid (integer)
 *  The term ID to begin with
 *
 * @var $quantity (integer)
 *  How many terms to return. If the number is positive, the function returns $quantity topics
 *  counting forward from $tid, with $tid as the first element.
 *  If it is negative, it returns $quantity topics counting backwards from $tid, with $tid as the
 *  last element. 
 * 
 */
function free_view_output_topic_json($tid, $quantity) {
  if (!is_numeric($tid)) {
    return FALSE;
  }
  $output = free_view_render_topics($tid, $quantity);
  //return render($output);
  drupal_json_output(render($output));
  drupal_exit();
}

/**
 * Fetch and render a topic via its taxonomy term ID, with previous and next links.
 *
 * @var $term (integer || object)
 *  The topic ID to display. The function will accept either a term ID or a loaded term object.
 *
 * @var $quantity (integer)
 *  How many terms to return. If the number is positive, the function returns $quantity topics
 *  counting forward from $tid, with $tid as the first element.
 *  If it is negative, it returns $quantity topics counting backwards from $tid, with $tid as the
 *  last element.
 *  You can get all of the topics at once by passing in a 0 value.
 *  
 * @return
 *  Rendered HTML for a topic.
 */
function free_view_render_topics($tid, $quantity = 0) {
  if($quantity == '' ) {
    preg_match('/quantity=(\d+)/sui', $_SERVER[QUERY_STRING], $match);
    $quantity = $match[1];
  }

  $term = is_numeric($tid) ? taxonomy_term_load($tid) : $tid;
  $vocab = taxonomy_vocabulary_load($term->vid);
  
  if (!in_array($vocab->machine_name, array('dynamic_documents_canon', 'dynamic_documents_permanent', 'dynamic_documents_temporary'))) {
    return '<div class="alert alert-danger"><h2>The topic you are looking for doesn\'t exist.</h2>Check the ID number supplied (' . $term->tid . ') and make sure it\'s correct.</div>';
  }
  
  // For now, I'm pulling the entire tree for this document. taxonomy_get_tree() has known
  // performance issues when scaling up to large vocabularies, so this method will have to be
  // refined using something more performant when we get bigger.
  $tree = taxonomy_get_tree($term->vid);
  
  // Loop through the terms and 1) create a side array of tids for reference, and 2) find the current location in the $tree array.
  $i = -1;
  foreach ($tree as $branch) {
    $tree_tids[] = $branch->tid;
    if (!isset($current_position)) {
      $i++;
      if ($branch->tid == $term->tid) {
        $current_position = $i;
      }
    }
  }
  if ($quantity > 0) {
    $slice = array_slice($tree, $current_position, $quantity);
    $current = reset($batch);
    $next = $tree[$current_position + $quantity];
    $previous = $tree[$current_position - 1];
  }
  else {
    // This works, but seems pretty hacky -- is there a better way to do a negative array_slice while maintaining pointers?
    $trim = array_slice($tree, 0, $current_position + 1);
    $slice = array_reverse(array_slice(array_reverse($trim), 0, -$quantity));
    $current = end($batch);
    $next = $tree[$current_position + 1];
    $previous = $tree[$current_position + $quantity - 1];
  }
  
  // Create a side array with batch tid keys
  foreach($slice as $temp) {
    $tids[$temp->tid] = array(
      'tid' => $temp->tid,
      'vid' => $temp->vid,
      'name' => $temp->name,
      'depth' => $temp->depth,      
      );
  }
  
  $previous_link = array(
    '#markup' => (count($previous) != 0) ? l('<span class="glyphicon glyphicon-arrow-up"></span> ' . $previous->name, 'jsondata/dynamic/docs/' . $previous->tid, array('html' => TRUE, 'attributes' => array('class' => array('btn', 'btn-default', 'btn-block', 'topic-nav-link', 'topic-nav-previous'), 'data-load' => $previous->tid))) : NULL,
  );
  
  $next_link = array(
    '#markup' => (count ($next) != 0) ? l('<span class="glyphicon glyphicon-arrow-down"></span> ' . $next->name, 'jsondata/dynamic/docs/' . $next->tid, array('html' => TRUE, 'attributes' => array('class' => array('btn', 'btn-default', 'btn-block', 'topic-nav-link', 'topic-nav-next'), 'data-load' => $next->tid))) : NULL,
  );
  
  // Build the content array
  $generic_container = array(
    '#type' => 'container',
    '#attributes' => array(
      'class' => array('col-md-10', 'col-md-offset-1', 'ajax-insert'),
    ),
  );
  $out = array(
    '#type' => 'container',
    '#attributes' => array(
      'class' => array('topic-wrapper-outer'),
    ),
  );
  
  $out['wrap'] = array(
    '#type' => 'container',
    '#attributes' => array(
      'class' => array('topic-wrapper', 'ajax-insert'),
    ),
  );
  
  if (count($previous) != 0 && $quantity < 0){
    $out['wrap']['previous'] = $generic_container + array('link' => $previous_link);
  }
  foreach ($tids as $tid => $item) {
    $term_wrapper = entity_metadata_wrapper('taxonomy_term', $tid);
    if (isset ($term_wrapper->field_topic_reference)) {
      $ref = $term_wrapper->field_topic_reference->value();
      if(isset($ref)){
        $topic_wrapper = entity_metadata_wrapper('node', $term_wrapper->field_topic_reference->value());
        $value = array(
          '#type' => 'container',
          '#attributes' => array(
            'class' => array('topic-content', 'col-md-10', 'col-md-offset-1', 'ajax-insert'),
            'data-topic' => $tid,
          ),
        );
        $value['contents'] = array('#markup' => $topic_wrapper->field_topic_processed_html->value->value());
        
        $out['wrap']['content'][$tid] = array(
          'title' => $generic_container + array('title' => array('#markup' => '<h' . ($item['depth']) . '>' . $item['name'] . '</h' . ($item['depth']) . '>')),
          'content' => $value,
        );
      }
      else {
        // Load the cover page.
        $out['wrap']['content'][$item->tid] = array(
          'content' => free_view_document_cover_page($tree[0]),
        );
      }
    }
    else {
      continue;
      //$content = '<div class="alert alert-warning"><h3>No content in this topic.</h3></div>';
    } 
  }
  if (count($next) != 0 && $quantity > 0) {
    $out['wrap']['next'] = $generic_container + array('link' => $next_link);  
  }
  return $out;
}


/**
 * Generate a cover page for a document.
 *
 */
function free_view_document_cover_page($term) {
  $content = array('#markup' => '<div class="alert alert-success"><h3>Cover page placeholder</h3>Put a TOC and fancy bits here!</div>');
  return $content;
}
